local RSS = {
    Version = "2.0.0",
    Author = "VETA (Refactored)",
    Services = {
        Players = game:GetService("Players"),
        RunService = game:GetService("RunService"),
        Workspace = game:GetService("Workspace"),
        ReplicatedStorage = game:GetService("ReplicatedStorage"),
        TweenService = game:GetService("TweenService")
    },
    Config = {
        Reach = {
            Enabled = false,
            Distance = 10,
            Visualizer = false,
            HitboxSize = Vector3.new(10, 10, 10)
        },
        Stamina = {
            Enabled = false,
            DefaultWalk = 16
        },
        GK = {
            AutoDive = false,
            DiveDistance = 10.3,
            DiveCooldown = 0.7,
            SmartDive = true
        },
        Prediction = {
            Enabled = false,
            UpdateRate = 3
        }
    },
    State = {
        LocalPlayer = game:GetService("Players").LocalPlayer,
        Connections = {},
        Hitbox = nil,
        CharacterParts = {}
    }
}

--// Services
local Players = RSS.Services.Players
local RunService = RSS.Services.RunService
local Workspace = RSS.Services.Workspace
local ReplicatedStorage = RSS.Services.ReplicatedStorage
local LocalPlayer = RSS.State.LocalPlayer

--// Utilities
local function GetRoot()
    return LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
end

local function GetBall()
    -- Cached lookup could be added here if needed, but finding by name is usually fast enough for single calls
    local b = Workspace:FindFirstChild("TPS") 
           or Workspace:FindFirstChild("PSoccerBall") 
           or Workspace:FindFirstChild("ball")
    
    -- Recursive search if not found at top level (expensive, use sparingly)
    if not b then
        b = Workspace:FindFirstChild("ball", true)
    end
    
    return b
end

local function GetCharacterParts()
    local char = LocalPlayer.Character
    if not char then return {} end
    
    -- Refresh cache if needed or just return new list
    local parts = {}
    for _, v in ipairs(char:GetChildren()) do
        if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" then -- Exclude root if desired, or keep it
            table.insert(parts, v)
        end
    end
    return parts
end

--// Module: Visualizer (Hitbox)
local function UpdateVisualizer()
    if RSS.State.Hitbox then
        RSS.State.Hitbox:Destroy()
        RSS.State.Hitbox = nil
    end

    if not RSS.Config.Reach.Visualizer and not RSS.Config.Reach.Enabled then return end
    
    -- Only show if enabled or visualizer toggle is on
    local shouldShow = RSS.Config.Reach.Visualizer
    
    local hitbox = Instance.new("BoxHandleAdornment")
    hitbox.Name = "RSSHitbox"
    hitbox.AlwaysOnTop = false
    hitbox.ZIndex = 10
    hitbox.Color3 = Color3.fromRGB(0, 255, 0)
    hitbox.Transparency = shouldShow and 0.8 or 1
    hitbox.Size = RSS.Config.Reach.HitboxSize
    hitbox.Adornee = GetRoot()
    hitbox.Parent = Workspace.Terrain
    
    local glow = Instance.new("BoxHandleAdornment")
    glow.Name = "Glow"
    glow.AlwaysOnTop = true
    glow.ZIndex = 0
    glow.Color3 = Color3.fromRGB(0, 255, 100)
    glow.Transparency = shouldShow and 0.7 or 1
    glow.Size = RSS.Config.Reach.HitboxSize * 1.05
    glow.Adornee = GetRoot()
    glow.Parent = hitbox
    
    RSS.State.Hitbox = hitbox
end

--// Module: Reach
local function ReachLoop()
    local root = GetRoot()
    if not root or not RSS.Config.Reach.Enabled then return end
    
    -- Update Adornee if it was lost
    if RSS.State.Hitbox and RSS.State.Hitbox.Adornee ~= root then
        RSS.State.Hitbox.Adornee = root
        if RSS.State.Hitbox:FindFirstChild("Glow") then
            RSS.State.Hitbox.Glow.Adornee = root
        end
    end

    local ball = GetBall()
    if not ball then return end

    local reachSize = RSS.Config.Reach.HitboxSize
    local effectiveReach = math.max(reachSize.X, reachSize.Y, reachSize.Z) / 2
    
    if (ball.Position - root.Position).Magnitude <= effectiveReach then
        local parts = GetCharacterParts()
        for i, part in ipairs(parts) do
            firetouchinterest(part, ball, 0)
            firetouchinterest(part, ball, 1)
            -- Optimization: Don't yield every single part, maybe every 5 parts if needed, 
            -- but for reach, instant is usually better. 
            -- Only yield if it causes lag.
        end
    end
end

local function ToggleReach(state)
    RSS.Config.Reach.Enabled = state
    UpdateVisualizer()
    
    if state then
        if not RSS.State.Connections.Reach then
            RSS.State.Connections.Reach = RunService.Heartbeat:Connect(ReachLoop)
        end
    else
        if RSS.State.Connections.Reach then
            RSS.State.Connections.Reach:Disconnect()
            RSS.State.Connections.Reach = nil
        end
    end
end

--// Module: Stamina
local function SetupStamina()
    -- Look for the stamina GUI
    local gui = LocalPlayer:WaitForChild("PlayerGui", 5)
    if not gui then return end
    
    local staminaFrame = gui:FindFirstChild("Stamina", true)
    if not staminaFrame then return end
    
    local speeds = staminaFrame:FindFirstChild("Speeds", true)
    if not speeds then return end
    
    -- Store default walkspeed if not already stored
    if RSS.Config.Stamina.DefaultWalk == 16 then
        RSS.Config.Stamina.DefaultWalk = speeds.Walk.Value
    end
    
    -- Clean up old connection
    if RSS.State.Connections.Stamina then
        RSS.State.Connections.Stamina:Disconnect()
        RSS.State.Connections.Stamina = nil
    end
    
    -- Create new connection to enforce speed
    RSS.State.Connections.Stamina = speeds.Walk:GetPropertyChangedSignal("Value"):Connect(function()
        if RSS.Config.Stamina.Enabled then
             if speeds.Walk.Value ~= speeds.Run.Value then
                speeds.Walk.Value = speeds.Run.Value
             end
        end
    end)
    
    -- Apply immediately
    if RSS.Config.Stamina.Enabled then
        speeds.Walk.Value = speeds.Run.Value
    end
end

local function ToggleStamina(state)
    RSS.Config.Stamina.Enabled = state
    SetupStamina() -- Re-run setup to apply or reset
    
    if not state then
        -- Try to reset to default (might not work if game overwrites constantly, but we try)
        -- We need to find the speeds object again or store it. 
        -- For simplicity, SetupStamina handles the logic via the connection check.
        -- When disabled, the connection will stop enforcing, but we might need to reset the value manually once.
        task.spawn(function()
             local gui = LocalPlayer:FindFirstChild("PlayerGui")
             local speeds = gui and gui:FindFirstChild("Speeds", true)
             if speeds then
                 speeds.Walk.Value = RSS.Config.Stamina.DefaultWalk
             end
        end)
    end
end

--// Module: GK Features (Auto Dive)
local function GetDiveButtons()
    local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
    if not playerGui then return nil, nil end
    
    local mobileCTRL = playerGui:FindFirstChild("MobileCTRL")
    local touchControlFrame = mobileCTRL and mobileCTRL:FindFirstChild("TouchControlFrame")
    local jumpButton = touchControlFrame and touchControlFrame:FindFirstChild("JumpButton")
    
    if jumpButton then
        return jumpButton:FindFirstChild("LeftDive"), jumpButton:FindFirstChild("RightDive")
    end
    return nil, nil
end

local function ClickButton(btn)
    if not btn then return end
    -- Support for different executor functions
    if getconnections then
        local connections = getconnections(btn.MouseButton1Click)
        if connections and #connections > 0 then
            for _, conn in ipairs(connections) do
                conn:Fire()
            end
            return
        end
    end
    -- Fallback
    if btn.MouseButton1Click then
        btn.MouseButton1Click:Fire()
    end
end

local lastDiveTime = 0

local function AutoDiveLoop()
    local ball = GetBall()
    if not ball then return end
    
    local root = GetRoot()
    if not root then return end
    
    local now = tick()
    if now - lastDiveTime < RSS.Config.GK.DiveCooldown then return end
    
    local distance = (root.Position - ball.Position).Magnitude
    if distance > RSS.Config.GK.DiveDistance then return end
    
    -- Smart Check: Is the ball actually moving towards us?
    local velocity = ball.AssemblyLinearVelocity
    local toBall = (ball.Position - root.Position).Unit
    local dot = velocity.Unit:Dot(toBall) 
    
    -- If dot is negative, ball is moving towards player (roughly). 
    -- However, in soccer games, we often want to dive even if it's just near us.
    -- Let's just stick to distance + side check for now, but refine the side check.
    
    local leftBtn, rightBtn = GetDiveButtons()
    if not leftBtn or not rightBtn then return end
    
    local relativePos = root.CFrame:PointToObjectSpace(ball.Position)
    
    -- Predict future position based on velocity for better accuracy
    local predictedPos = relativePos + (root.CFrame:VectorToObjectSpace(velocity) * 0.2) -- 0.2s prediction
    
    if predictedPos.X < 0 then
        ClickButton(leftBtn)
    else
        ClickButton(rightBtn)
    end
    lastDiveTime = now
end

local function ToggleAutoDive(state)
    RSS.Config.GK.AutoDive = state
    
    if state then
        if not RSS.State.Connections.AutoDive then
            RSS.State.Connections.AutoDive = RunService.Heartbeat:Connect(AutoDiveLoop)
        end
    else
        if RSS.State.Connections.AutoDive then
            RSS.State.Connections.AutoDive:Disconnect()
            RSS.State.Connections.AutoDive = nil
        end
    end
end

--// Module: Ball Predictor
local Predictor = {}
Predictor.Folder = nil
Predictor.Segments = {}
Predictor.Config = {
    gravity = 196.2,
    bounceDamping = 0.65, -- Slightly adjusted
    segmentCount = 25,
    maxSimulationPoints = 80,
    segmentSize = Vector3.new(0.3, 0.3, 2)
}

function Predictor.Init()
    Predictor.Folder = Instance.new("Folder")
    Predictor.Folder.Name = "RSSPrediction"
    Predictor.Folder.Parent = Workspace
    
    for i = 1, Predictor.Config.segmentCount do
        local p = Instance.new("Part")
        p.Name = "Seg_" .. i
        p.Anchored = true
        p.CanCollide = false
        p.Material = Enum.Material.Neon
        p.Color = Color3.fromRGB(0, 255, 0)
        p.Transparency = 1
        p.Size = Predictor.Config.segmentSize
        p.Parent = Predictor.Folder
        Predictor.Segments[i] = p
    end
    
    -- Add Landing Marker
    local marker = Instance.new("Part")
    marker.Name = "Landing"
    marker.Anchored = true
    marker.CanCollide = false
    marker.Shape = Enum.PartType.Cylinder
    marker.Size = Vector3.new(1, 4, 4) -- Rotated
    marker.Color = Color3.fromRGB(255, 0, 0)
    marker.Transparency = 1
    marker.Parent = Predictor.Folder
    Predictor.Landing = marker
end

function Predictor.Cleanup()
    if Predictor.Folder then
        Predictor.Folder:Destroy()
        Predictor.Folder = nil
    end
    Predictor.Segments = {}
end

function Predictor.Simulate(startPos, startVel)
    local points = {}
    local pos = startPos
    local vel = startVel
    local dt = 0.033
    local gravity = Vector3.new(0, -Predictor.Config.gravity, 0)
    
    for i = 1, Predictor.Config.maxSimulationPoints do
        table.insert(points, pos)
        
        vel = vel + gravity * dt
        local nextPos = pos + vel * dt
        
        -- Simple ground collision
        if nextPos.Y < 0 and vel.Y < 0 then
            vel = Vector3.new(vel.X, -vel.Y * Predictor.Config.bounceDamping, vel.Z)
            nextPos = Vector3.new(nextPos.X, 0, nextPos.Z)
        end
        
        pos = nextPos
        if pos.Y < -10 then break end
    end
    
    return points
end

local frameCount = 0
local function PredictorLoop()
    frameCount = frameCount + 1
    if frameCount % RSS.Config.Prediction.UpdateRate ~= 0 then return end
    
    local ball = GetBall()
    if not ball or ball.AssemblyLinearVelocity.Magnitude < 1 then
        for _, seg in ipairs(Predictor.Segments) do seg.Transparency = 1 end
        if Predictor.Landing then Predictor.Landing.Transparency = 1 end
        return
    end
    
    local points = Predictor.Simulate(ball.Position, ball.AssemblyLinearVelocity)
    local count = #points
    
    -- Draw Segments
    local segmentStep = math.max(1, math.floor(count / Predictor.Config.segmentCount))
    
    for i = 1, Predictor.Config.segmentCount do
        local idx = (i - 1) * segmentStep + 1
        local nextIdx = idx + segmentStep
        
        if points[idx] and points[nextIdx] then
            local p1 = points[idx]
            local p2 = points[nextIdx]
            local dist = (p2 - p1).Magnitude
            local cf = CFrame.lookAt((p1 + p2)/2, p2)
            
            Predictor.Segments[i].Size = Vector3.new(0.3, 0.3, dist)
            Predictor.Segments[i].CFrame = cf
            Predictor.Segments[i].Transparency = 0.3
        else
            Predictor.Segments[i].Transparency = 1
        end
    end
    
    -- Draw Landing
    if Predictor.Landing then
        -- Find first point near ground
        local landingPos = nil
        for _, p in ipairs(points) do
            if p.Y <= 0.5 then
                landingPos = p
                break
            end
        end
        
        if landingPos then
            Predictor.Landing.CFrame = CFrame.new(landingPos) * CFrame.Angles(0, 0, math.pi/2)
            Predictor.Landing.Transparency = 0.5
        else
            Predictor.Landing.Transparency = 1
        end
    end
end

local function TogglePredictor(state)
    RSS.Config.Prediction.Enabled = state
    
    if state then
        Predictor.Init()
        if not RSS.State.Connections.Predictor then
            RSS.State.Connections.Predictor = RunService.Heartbeat:Connect(PredictorLoop)
        end
    else
        Predictor.Cleanup()
        if RSS.State.Connections.Predictor then
            RSS.State.Connections.Predictor:Disconnect()
            RSS.State.Connections.Predictor = nil
        end
    end
end

--// UI Setup (WindUI)
local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/refs/heads/main/dist/main.lua"))()

local Window = WindUI:CreateWindow({
    Title = "RSS - VETA [Refactored]",
    Icon = "rbxassetid://106211849494703",
    Author = "VETA",
    Folder = "RSSVETA"
})

-- TABS
local MainTab = Window:Tab({ Title = "Reach", Icon = "target" })
local GkTab = Window:Tab({ Title = "GK Features", Icon = "shield" })
local StaminaTab = Window:Tab({ Title = "Stamina", Icon = "zap" })
local PredictTab = Window:Tab({ Title = "Predictor", Icon = "activity" })

-- SECTIONS & ELEMENTS

-- [Main Tab]
local ReachSection = MainTab:Section({ Title = "Hitbox & Reach" })

ReachSection:Toggle({
    Title = "Enable Reach",
    Default = false,
    Callback = ToggleReach
})

ReachSection:Toggle({
    Title = "Visualizer",
    Default = false,
    Callback = function(v)
        RSS.Config.Reach.Visualizer = v
        UpdateVisualizer()
    end
})

ReachSection:Slider({
    Title = "Hitbox Size X",
    Step = 1,
    Value = { Min = 1, Max = 50, Default = 10 },
    Callback = function(v)
        RSS.Config.Reach.HitboxSize = Vector3.new(v, RSS.Config.Reach.HitboxSize.Y, RSS.Config.Reach.HitboxSize.Z)
        UpdateVisualizer()
    end
})
ReachSection:Slider({
    Title = "Hitbox Size Y",
    Step = 1,
    Value = { Min = 1, Max = 50, Default = 10 },
    Callback = function(v)
        RSS.Config.Reach.HitboxSize = Vector3.new(RSS.Config.Reach.HitboxSize.X, v, RSS.Config.Reach.HitboxSize.Z)
        UpdateVisualizer()
    end
})
ReachSection:Slider({
    Title = "Hitbox Size Z",
    Step = 1,
    Value = { Min = 1, Max = 50, Default = 10 },
    Callback = function(v)
        RSS.Config.Reach.HitboxSize = Vector3.new(RSS.Config.Reach.HitboxSize.X, RSS.Config.Reach.HitboxSize.Y, v)
        UpdateVisualizer()
    end
})

-- [GK Tab]
local GKSection = GkTab:Section({ Title = "Auto Features" })

GKSection:Toggle({
    Title = "Auto Dive",
    Desc = "Attempts to dive when ball is near (Beta)",
    Default = false,
    Callback = ToggleAutoDive
})

GKSection:Dropdown({
    Title = "Quick Team",
    Values = {"Home GK", "Away GK"},
    Multi = false,
    Callback = function(v)
        if not v then return end
        local args = nil
        if v == "Home GK" then
            args = {BrickColor.new(23), "Goalie"}
        elseif v == "Away GK" then
            args = {BrickColor.new(141), "Goalie"}
        end
        
        if args then
             ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TeamChange"):FireServer(unpack(args))
        end
    end
})

-- [Stamina Tab]
local StaminaSection = StaminaTab:Section({ Title = "Settings" })
StaminaSection:Toggle({
    Title = "Infinite Stamina",
    Default = false,
    Callback = ToggleStamina
})

-- [Predictor Tab]
local PredictSection = PredictTab:Section({ Title = "Ball Trajectory" })
PredictSection:Toggle({
    Title = "Enable Predictor",
    Default = false,
    Callback = TogglePredictor
})

WindUI:Notify({
    Title = "Loaded",
    Content = "RSS Refactored Loaded Successfully",
    Duration = 5
})
