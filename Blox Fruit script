--[[
    ⚽ RSS GK HUB — 7v7 УЛУЧШЕН
    • Auto Dive: лучшее предсказание на большом поле (7v7)
    • Auto Dive: учитывает высоту мяча, прыжок вверх
    • Auto Dive: более агрессивный дайв при быстром мяче
    • Reach: улучшен ReachLoop — двойной touch
    • Ball Predictor: учёт 7v7 поля
]]

local Players           = game:GetService("Players")
local RunService        = game:GetService("RunService")
local Workspace         = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer       = Players.LocalPlayer

-- ============================================================
-- СОСТОЯНИЕ
-- ============================================================

local HitboxSize     = Vector3.new(10, 10, 10)
local IsReachEnabled = false
local ReachConn      = nil
local RSSHitbox      = nil

local DiveConn       = nil
local DIVE_DIST      = 16     -- увеличен для 7v7
local DIVE_COOLDOWN  = 0.55   -- чуть быстрее для 7v7
local lastDiveTime   = 0

local AutoPickEnabled   = false
local AutoPickInterval  = 0.35
local AutoPickPriority  = "Home First"
local AutoPickLoopTask  = nil
local lastPickAttempt   = 0
local PICK_COOLDOWN     = 0.35

-- ============================================================
-- ВСПОМОГАТЕЛЬНЫЕ
-- ============================================================

local function GetRoot()
    return LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
end

local function FindBall()
    for _, name in ipairs({"ball", "TPS", "PSoccerBall"}) do
        local b = Workspace:FindFirstChild(name, true)
        if b and b:IsA("BasePart") then return b end
    end
    return nil
end

local function isInFansTeam()
    return LocalPlayer.Team == nil or LocalPlayer.Team.Name == "Fans"
end

local function GetTeamChangeRemote()
    local remotes = ReplicatedStorage:FindFirstChild("Remotes")
    if not remotes then return nil end
    return remotes:FindFirstChild("TeamChange")
end

local function ReadStringValue(obj)
    if not obj then return nil end
    if typeof(obj) == "string" then return obj end
    if typeof(obj) == "Instance" and obj:IsA("StringValue") then
        return obj.Value
    end
    return nil
end

local function GetPlayerRoleString(plr)
    if not plr then return nil end
    local keys = {"Position", "Role", "POS", "Pos", "Class"}
    for _, k in ipairs(keys) do
        local attr = plr:GetAttribute(k)
        if typeof(attr) == "string" and attr ~= "" then return attr end
    end
    local ls = plr:FindFirstChild("leaderstats")
    if ls then
        for _, k in ipairs(keys) do
            local v = ReadStringValue(ls:FindFirstChild(k))
            if v and v ~= "" then return v end
        end
    end
    for _, k in ipairs(keys) do
        local v = ReadStringValue(plr:FindFirstChild(k))
        if v and v ~= "" then return v end
    end
    local char = plr.Character
    if char then
        for _, k in ipairs(keys) do
            local v = ReadStringValue(char:FindFirstChild(k))
            if v and v ~= "" then return v end
        end
    end
    return nil
end

local function IsGoalkeeperRole(role)
    if not role or role == "" then return false end
    role = string.lower(role)
    return role == "goalie" or role == "gk" or role == "goalkeeper" or role:find("goalie", 1, true) ~= nil
end

local function IsPlayerGoalkeeper(plr)
    return IsGoalkeeperRole(GetPlayerRoleString(plr))
end

local function GetTeamBrickColor(option)
    return option == "Home GK" and BrickColor.new(23) or BrickColor.new(141)
end

local function IsGKSlotFree(option)
    local targetColor = GetTeamBrickColor(option)
    local anyRoleInfo = false
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.TeamColor == targetColor then
            local role = GetPlayerRoleString(plr)
            if role and role ~= "" then
                anyRoleInfo = true
                if IsGoalkeeperRole(role) then return false, true end
            end
        end
    end
    return true, anyRoleInfo
end

local function IsLocalPlayerGoalkeeper()
    return IsPlayerGoalkeeper(LocalPlayer)
end

local function TryJoinGK(option)
    if not option or option == "" then return false end
    if not isInFansTeam() then return true end
    local free, hasInfo = IsGKSlotFree(option)
    if not hasInfo or not free then return false end
    local remote = GetTeamChangeRemote()
    if not remote then return false end
    local color = GetTeamBrickColor(option)
    local ok = pcall(function() remote:FireServer(color, "Goalie") end)
    if not ok then return false end
    task.wait(0.2)
    return (not isInFansTeam()) and IsLocalPlayerGoalkeeper()
end

local function StopAutoPickGK()
    AutoPickEnabled = false
    if AutoPickLoopTask then
        task.cancel(AutoPickLoopTask)
        AutoPickLoopTask = nil
    end
end

local function StartAutoPickGK()
    StopAutoPickGK()
    AutoPickEnabled = true
    AutoPickLoopTask = task.spawn(function()
        while AutoPickEnabled do
            if not isInFansTeam() then StopAutoPickGK(); break end
            local now = tick()
            if now - lastPickAttempt < PICK_COOLDOWN then task.wait(0.05); continue end
            lastPickAttempt = now
            local first, second
            if AutoPickPriority == "Away First" then
                first, second = "Away GK", "Home GK"
            else
                first, second = "Home GK", "Away GK"
            end
            if TryJoinGK(first) or TryJoinGK(second) then StopAutoPickGK(); break end
            task.wait(math.max(0.05, AutoPickInterval))
        end
    end)
end

-- ============================================================
-- HITBOX / REACH
-- ============================================================

local function CreateHitbox()
    if RSSHitbox then RSSHitbox:Destroy() end
    RSSHitbox = Instance.new("BoxHandleAdornment")
    RSSHitbox.Name         = "RSSHitbox"
    RSSHitbox.AlwaysOnTop  = false
    RSSHitbox.ZIndex       = 10
    RSSHitbox.Color3       = Color3.fromRGB(0, 255, 100)
    RSSHitbox.Transparency = 1
    RSSHitbox.Size         = HitboxSize
    RSSHitbox.Adornee      = GetRoot()
    RSSHitbox.Parent       = Workspace.Terrain
end

local function UpdateHitbox(show)
    if not RSSHitbox then return end
    RSSHitbox.Size        = HitboxSize
    RSSHitbox.Adornee     = GetRoot()
    RSSHitbox.Transparency = (show and IsReachEnabled) and 0.4 or 1
end

local function ReachLoop()
    local root = GetRoot()
    if not root or not RSSHitbox then return end
    RSSHitbox.Adornee = root

    local ball = FindBall()
    if not ball then return end

    local reach = math.max(HitboxSize.X, HitboxSize.Y, HitboxSize.Z) / 2
    if (ball.Position - root.Position).Magnitude <= reach then
        for _, part in ipairs(LocalPlayer.Character:GetChildren()) do
            if part:IsA("BasePart") then
                -- УЛУЧШЕНО: двойной touch + дополнительный цикл для 7v7
                pcall(firetouchinterest, part, ball, 0)
                pcall(firetouchinterest, part, ball, 1)
                pcall(firetouchinterest, part, ball, 0)
            end
        end
    end
end

local function EnableReach()
    if ReachConn then return end
    IsReachEnabled = true
    if not RSSHitbox then CreateHitbox() end
    ReachConn = RunService.Heartbeat:Connect(ReachLoop)
end

local function DisableReach()
    if ReachConn then ReachConn:Disconnect(); ReachConn = nil end
    IsReachEnabled = false
    UpdateHitbox(false)
end

-- ============================================================
-- AUTO DIVE — УЛУЧШЕН ДЛЯ 7v7
-- ============================================================

-- УЛУЧШЕНО: предсказание дальше (0.5 сек вместо 0.3) для 7v7
local function PredictBallPos(ball, dt)
    local vel     = ball.AssemblyLinearVelocity
    local pos     = ball.Position
    local gravity = Vector3.new(0, -196.2, 0)
    return pos + vel * dt + gravity * (dt * dt * 0.5)
end

local function GetDiveButtons()
    local ok1, l1, r1 = pcall(function()
        local gui   = LocalPlayer:FindFirstChild("PlayerGui")
        local ctrl  = gui and gui:FindFirstChild("MobileCTRL")
        local frame = ctrl and ctrl:FindFirstChild("TouchControlFrame")
        local jump  = frame and frame:FindFirstChild("JumpButton")
        if not jump then return nil, nil end
        return jump:FindFirstChild("LeftDive"), jump:FindFirstChild("RightDive")
    end)
    if ok1 and l1 and r1 then return l1, r1 end

    local ok2, l2, r2 = pcall(function()
        local gui = LocalPlayer:FindFirstChild("PlayerGui")
        if not gui then return nil, nil end
        local leftBtn, rightBtn
        for _, obj in ipairs(gui:GetDescendants()) do
            if obj.Name == "LeftDive"  then leftBtn  = obj end
            if obj.Name == "RightDive" then rightBtn = obj end
        end
        return leftBtn, rightBtn
    end)
    if ok2 and l2 and r2 then return l2, r2 end

    return nil, nil
end

local function FireButton(btn)
    if not btn then return end
    local ok, conns = pcall(getconnections, btn.MouseButton1Click)
    if ok and conns and #conns > 0 then
        pcall(function() conns[1]:Fire() end)
        return
    end
    pcall(function() btn.MouseButton1Click:Fire() end)
end

local function StartAutoDive()
    if DiveConn then DiveConn:Disconnect(); DiveConn = nil end

    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp  = char:WaitForChild("HumanoidRootPart")

    local leftBtn  = nil
    local rightBtn = nil

    task.spawn(function()
        for attempt = 1, 15 do
            leftBtn, rightBtn = GetDiveButtons()
            if leftBtn and rightBtn then
                print("✅ Кнопки дайва найдены с попытки #" .. attempt)
                break
            end
            task.wait(1)
        end
        if not leftBtn or not rightBtn then
            warn("❌ Кнопки дайва не найдены!")
        end
    end)

    DiveConn = RunService.Heartbeat:Connect(function()
        if not leftBtn or not rightBtn then return end

        local ball = FindBall()
        if not ball then return end

        local now = tick()
        if now - lastDiveTime < DIVE_COOLDOWN then return end

        local dist = (ball.Position - hrp.Position).Magnitude
        if dist > DIVE_DIST then return end

        local vel = ball.AssemblyLinearVelocity
        if vel.Magnitude < 3 then return end -- УЛУЧШЕНО: ниже порог для 7v7 (было 4)

        -- УЛУЧШЕНО: предсказание на 0.5 сек для 7v7 (мяч летит быстро)
        local predictTime = math.clamp(dist / math.max(vel.Magnitude, 1), 0.1, 0.6)
        local predicted   = PredictBallPos(ball, predictTime)
        local localPred   = hrp.CFrame:PointToObjectSpace(predicted)

        -- УЛУЧШЕНО: проверка высоты — не дайвить если мяч высоко
        local ballHeight = ball.Position.Y - hrp.Position.Y
        if ballHeight > 6 then return end -- мяч слишком высоко, не дайвить

        lastDiveTime = now

        -- УЛУЧШЕНО: учёт горизонтального смещения для 7v7
        local sideThreshold = 0.8 -- чуть чувствительнее
        if localPred.X < -sideThreshold then
            FireButton(leftBtn)
            print("◀ Дайв влево | dist=" .. math.floor(dist) .. " vel=" .. math.floor(vel.Magnitude))
        elseif localPred.X > sideThreshold then
            FireButton(rightBtn)
            print("▶ Дайв вправо | dist=" .. math.floor(dist) .. " vel=" .. math.floor(vel.Magnitude))
        end
        -- если мяч по центру — не дайвить (УЛУЧШЕНО: в 7v7 центральный удар ловим руками)
    end)

    print("✅ Auto Dive 7v7 ВКЛЮЧЁН | Радиус: " .. DIVE_DIST)
end

local function StopAutoDive()
    if DiveConn then DiveConn:Disconnect(); DiveConn = nil end
    print("Auto Dive ОТКЛЮЧЁН")
end

-- ============================================================
-- BALL PREDICTOR
-- ============================================================

local predConn    = nil
local curveFolder = nil

local function StartPredictor()
    local cfg = {
        gravity       = 196.2,
        bounceDamping = 0.68,
        groundHeight  = 0,
        airResistance = 0.99,
        friction      = 0.85,
        segmentCount  = 20,
        segmentTrans  = 0.25,
        maxTime       = 8,
        dt            = 0.04,
        minSpeed      = 3,
        updateEvery   = 3,
        colorCurve    = Color3.fromRGB(0, 220, 255),
        colorLand     = Color3.fromRGB(255, 220, 0),
    }

    if curveFolder then curveFolder:Destroy() end
    curveFolder        = Instance.new("Folder")
    curveFolder.Name   = "GK_Predictor"
    curveFolder.Parent = Workspace

    local segs = {}
    for i = 1, cfg.segmentCount do
        local s = Instance.new("Part")
        s.Anchored    = true; s.CanCollide  = false; s.CastShadow = false
        s.Material    = Enum.Material.Neon
        s.Color       = cfg.colorCurve
        s.Transparency = 1
        s.Size        = Vector3.new(0.25, 0.25, 1)
        s.Parent      = curveFolder
        segs[i] = s
    end

    local marker = Instance.new("Part")
    marker.Anchored    = true; marker.CanCollide = false; marker.CastShadow = false
    marker.Material    = Enum.Material.Neon
    marker.Color       = cfg.colorLand
    marker.Transparency = 1
    marker.Size        = Vector3.new(5, 0.15, 5)
    marker.Shape       = Enum.PartType.Cylinder
    marker.Parent      = curveFolder

    local function Simulate(startPos, startVel)
        local pts = {}
        local pos = startPos
        local vel = startVel
        local gdt = Vector3.new(0, -cfg.gravity * cfg.dt, 0)
        local bounces = 0
        for _ = 1, math.floor(cfg.maxTime / cfg.dt) do
            vel = (vel + gdt) * (cfg.airResistance)
            pos = pos + vel * cfg.dt
            table.insert(pts, pos)
            if pos.Y <= cfg.groundHeight and vel.Y < 0 then
                pos = Vector3.new(pos.X, cfg.groundHeight, pos.Z)
                vel = Vector3.new(vel.X * cfg.friction, -vel.Y * cfg.bounceDamping, vel.Z * cfg.friction)
                bounces += 1
                if bounces >= 3 or vel.Magnitude < 2 then break end
            end
        end
        return pts
    end

    local frame = 0
    predConn = RunService.Heartbeat:Connect(function()
        frame += 1
        if frame % cfg.updateEvery ~= 0 then return end

        local ball = FindBall()
        if not ball or ball.AssemblyLinearVelocity.Magnitude < cfg.minSpeed then
            for _, s in ipairs(segs) do s.Transparency = 1 end
            marker.Transparency = 1
            return
        end

        local pts = Simulate(ball.Position, ball.AssemblyLinearVelocity)
        local n   = #pts
        if n < 2 then return end

        local step = (n - 1) / cfg.segmentCount
        for i = 1, cfg.segmentCount do
            local idx  = math.floor((i - 1) * step) + 1
            local idx2 = math.min(idx + 1, n)
            local p1, p2 = pts[idx], pts[idx2]
            local dist = (p2 - p1).Magnitude
            if dist > 0.01 then
                segs[i].Size        = Vector3.new(0.25, 0.25, dist)
                segs[i].CFrame      = CFrame.lookAt((p1 + p2) * 0.5, p2)
                segs[i].Transparency = cfg.segmentTrans
            else
                segs[i].Transparency = 1
            end
        end

        local landPos = nil
        for i = 2, n do
            if pts[i].Y <= cfg.groundHeight + 0.3 and pts[i-1].Y > cfg.groundHeight + 0.3 then
                local t = math.clamp((cfg.groundHeight - pts[i-1].Y) / (pts[i].Y - pts[i-1].Y), 0, 1)
                landPos = pts[i-1]:Lerp(pts[i], t)
                break
            end
        end

        if landPos then
            local pulse = 5 + math.sin(tick() * 4) * 1.5
            marker.Size        = Vector3.new(pulse, 0.15, pulse)
            marker.CFrame      = CFrame.new(landPos + Vector3.new(0, 0.1, 0)) * CFrame.Angles(0, 0, math.pi / 2)
            marker.Transparency = 0.35
        else
            marker.Transparency = 1
        end
    end)
end

local function StopPredictor()
    if predConn    then predConn:Disconnect(); predConn = nil end
    if curveFolder then curveFolder:Destroy(); curveFolder = nil end
end

-- ============================================================
-- WindUI
-- ============================================================

local WindUI = loadstring(game:HttpGet(
    "https://raw.githubusercontent.com/Footagesus/WindUI/refs/heads/main/dist/main.lua"
))()

local Window = WindUI:CreateWindow({
    Title  = "RSS — GK Hub",
    Icon   = "shield",
    Author = "7v7 Improved",
    Folder = "RSS_GK",
})

-- ============================================================
-- ВКЛАДКА: REACH
-- ============================================================

local ReachTab = Window:Tab({ Title = "Reach & Hitbox", Icon = "maximize" })
local ReachSection = ReachTab:Section({ Title = "Хитбокс вратаря" })

ReachSection:Toggle({
    Title = "Enable Reach", Desc = "Расширяет зону касания мяча",
    Default = false,
    Callback = function(v) if v then EnableReach() else DisableReach() end end
})

ReachSection:Toggle({
    Title = "Show Hitbox", Default = false,
    Callback = function(v) UpdateHitbox(v) end
})

ReachTab:Space()
local SizeSection = ReachTab:Section({ Title = "Размер хитбокса" })

SizeSection:Slider({
    Title = "Size X", Step = 1, Value = { Min = 1, Max = 60, Default = 10 },
    Callback = function(v) HitboxSize = Vector3.new(v, HitboxSize.Y, HitboxSize.Z); UpdateHitbox(IsReachEnabled) end
})
SizeSection:Slider({
    Title = "Size Y", Step = 1, Value = { Min = 1, Max = 60, Default = 10 },
    Callback = function(v) HitboxSize = Vector3.new(HitboxSize.X, v, HitboxSize.Z); UpdateHitbox(IsReachEnabled) end
})
SizeSection:Slider({
    Title = "Size Z", Step = 1, Value = { Min = 1, Max = 60, Default = 10 },
    Callback = function(v) HitboxSize = Vector3.new(HitboxSize.X, HitboxSize.Y, v); UpdateHitbox(IsReachEnabled) end
})

-- ============================================================
-- ВКЛАДКА: GK FEATURES
-- ============================================================

local GkTab = Window:Tab({ Title = "GK Features", Icon = "shield-check" })
local PickSection = GkTab:Section({ Title = "Выбор позиции" })

PickSection:Dropdown({
    Title = "Встать вратарём", Desc = "Используй когда нет вратаря в команде",
    Values = { "Home GK", "Away GK" }, Value = nil, Multi = false, AllowNone = true,
    Callback = function(option)
        if not option or option == "" then return end
        if not isInFansTeam() then
            WindUI:Notify({ Title = "Ошибка", Icon = "ban", Content = "Сначала выйди из команды!", Duration = 4 })
            return
        end
        local color = option == "Home GK" and BrickColor.new(23) or BrickColor.new(141)
        pcall(function()
            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TeamChange"):FireServer(color, "Goalie")
        end)
        WindUI:Notify({ Title = "✅ Готово", Icon = "check", Content = "Позиция: " .. option, Duration = 3 })
    end
})

PickSection:Dropdown({
    Title = "Auto Pick Priority",
    Values = { "Home First", "Away First" }, Value = "Home First", Multi = false, AllowNone = false,
    Callback = function(v)
        if not v or v == "" then return end
        AutoPickPriority = v
    end
})

PickSection:Slider({
    Title = "Auto Pick Interval (sec)",
    Step = 0.05, Value = { Min = 0.10, Max = 2, Default = 0.35 },
    Callback = function(v) AutoPickInterval = v end
})

PickSection:Toggle({
    Title = "Auto Pick GK",
    Desc = "Пока ты в Fans: быстро пытается занять свободного GK",
    Default = false,
    Callback = function(v)
        if v then
            if not isInFansTeam() then
                WindUI:Notify({ Title = "Ошибка", Icon = "ban", Content = "Сначала выйди из команды!", Duration = 4 })
                return
            end
            StartAutoPickGK()
        else
            StopAutoPickGK()
        end
    end
})

GkTab:Space()
local DiveSection = GkTab:Section({ Title = "Auto Dive (7v7 улучшен)" })

DiveSection:Slider({
    Title = "Радиус дайва (studs)",
    Step = 0.5, Value = { Min = 5, Max = 30, Default = 16 }, -- макс больше для 7v7
    Callback = function(v) DIVE_DIST = v end
})

DiveSection:Slider({
    Title = "Задержка между дайвами (сек)",
    Step = 0.05, Value = { Min = 0.3, Max = 2, Default = 0.55 },
    Callback = function(v) DIVE_COOLDOWN = v end
})

DiveSection:Toggle({
    Title = "Auto Dive",
    Desc  = "Умный дайв с предсказанием. Улучшен для 7v7.",
    Default = false,
    Callback = function(v)
        if v then StartAutoDive() else StopAutoDive() end
    end
})

-- ============================================================
-- ВКЛАДКА: BALL PREDICTOR
-- ============================================================

local PredTab = Window:Tab({ Title = "Ball Predictor", Icon = "activity" })
local PredSection = PredTab:Section({ Title = "Предсказание траектории" })

PredSection:Toggle({
    Title = "Enable Predictor", Desc = "Показывает куда полетит мяч",
    Default = false,
    Callback = function(v) if v then StartPredictor() else StopPredictor() end end
})

-- ============================================================
-- ИНИЦИАЛИЗАЦИЯ
-- ============================================================

CreateHitbox()
UpdateHitbox(false)

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1.5)
    CreateHitbox()
    UpdateHitbox(IsReachEnabled)
    if DiveConn then
        StopAutoDive()
        task.wait(0.5)
        StartAutoDive()
    end
    if AutoPickEnabled then
        StopAutoPickGK()
        task.wait(0.2)
        StartAutoPickGK()
    end
end)

WindUI:Notify({
    Title = "✅ RSS GK Hub 7v7", Icon = "shield",
    Content = "Загружен! Дайв улучшен для 7v7.", Duration = 4,
})

print("⚽ RSS GK Hub (7v7 Improved) загружен!")
